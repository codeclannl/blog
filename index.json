[{"body":"De Clan Hoe mooi is het om te zien dat iedereen zijn of haar talent ontwikkelt en het maximaal haalbare uit hun capaciteiten probeert te halen. Iedereen is anders en iedereen is uniek, maar de wil en motivatie om jezelf te ontwikkelen bezitten we allemaal. Wij gaan er niet vanuit dat we alles al weten en kennen, maar wel een gezonde interesse in nieuwe ontwikkelingen, technieken en tools hebben. Als we iedere dag een stapje maken als persoon dan maken we als organisatie grote stappen, hebben we tevreden klanten en kunnen we net die extra stappen maken naar het onverwachte.\n","link":"https://example.com/about/","section":"","tags":null,"title":"About"},{"body":"","link":"https://example.com/","section":"","tags":null,"title":"Clarity"},{"body":"","link":"https://example.com/tags/commenting/","section":"tags","tags":null,"title":"commenting"},{"body":"","link":"https://example.com/tags/pair-programming/","section":"tags","tags":null,"title":"pair-programming"},{"body":"","link":"https://example.com/posts/","section":"posts","tags":null,"title":"Posts"},{"body":"","link":"https://example.com/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"Programmers are always learning. Whether it's learning a new language, a new framework, design patterns, or even a keyboard shortcut. It makes them and their team more productive, saving valuable time for their company. But we rarely talk about the skill of making code easy to understand, about commenting and the enormous impact it can have on the productivity of a team. So let's put the art of commenting in the spotlight it deserves.\nHow important can commenting really be? “Indeed, the ratio of time spent reading versus writing is well over 10 to 1. We are constantly reading old code as part of the effort to write new code. ...[Therefore,] making it easy to read makes it easier to write.” - Robert C. Martin\nThis quote really captures why more attention should go to writing comments. To write correct code, you first need to understand its context. To do so requires a lot of reading and in practice, you have to read a lot of code that you did not write yourself.\nSure, you save time by being knowledgeable in the language you have to write. But how much time can be saved in the future by making your code readable?\nFor those who are interested, here's a story on how one character and no comments cost our team four hours:\nMy team and I were working on a big new feature. This feature required a few new Spring microservices to be created. Each required similar auto-configuration to configure its database. The first microservice (called A) worked like a charm. It contained this (simplified) code fragment:\n1@Bean 2@ConditionalOnClass(TargetDataSources.class) 3public List\u0026lt;A\u0026gt; ABeans(TargetDataSources targetDatasources) { 4 targetDatasources.stream().map(d - \u0026gt; { 5 A a = A.create(); 6 a.setChangeLog(\u0026#34;classpath:a-changelog.yaml\u0026#34;); 7 a.setDataSource(d); 8 a.setResourceLoader(applicationContext); 9 }).collect(Collectors.toList()); 10}``` 11 12*A colleague of mine was working in a different microservice B and wrote the following code fragment: * 13 14```java 15@Bean 16@ConditionalOnClass(TargetDataSources.class) 17public List\u0026lt;B\u0026gt; BBeans(TargetDataSources targetDataSources) { 18 targetDataSources.stream().map(ds - \u0026gt; { 19 B b = B.create(); 20 b.setChangeLog(\u0026#34;classpath:b-changelog.yaml\u0026#34;); 21 b.setDataSource(ds); 22 b.setResourceLoader(applicationContext); 23 }).collect(Collectors.toList()); 24}``` 25 26*Looks pretty similar right? Well, it did not work. Can you guess why? My colleague looked at it for a while (say 30 minutes) and could not figure out the problem. He asked another colleague, who did not know it either. Then another. More time passed by, then I was invited into the call. They had done some more debugging and brainstorming and had remembered that I had worked on microservice A. Maybe I would have some useful insights.* 27 28*At first, I could not figure out the problem either. Then it hit me. **The name of the parameter was the clue**. See, the parameter of the example method was injected. As a team, we normally only dealt with dependency injection with one bean per interface. However, in these microservices, we used an extra library that introduced a second Bean of the type `TargetDataSources`. The library had foreseen this conflict and had \u0026#39;cleverly\u0026#39; named their bean `TargetDatasources`. With a lowercase s! The other bean was named `TargetDataSources`. In both our microservices, we needed the bean with the lowercase s to be injected, which is why A was working and B was not. * 29 30 31![named_bean_injection.drawio.png::image-medium](https://cdn.hashnode.com/res/hashnode/image/upload/v1650708962509/voQOf-QXf.png) 32 33*No exception was occurring, because Spring was able to differentiate between the candidates based on the parameter name. To fix the bug, you had to know there were *two* candidates in the context and you had to know their case-sensitive names.* 34 35So what\u0026#39;s the moral of this story? **I should have added a comment pointing out the casing of the parameter and its importance. That one line of commenting would have saved hours of debugging**. But when writing the fragment (months earlier) I had also spent hours figuring out I needed that casing. And once it finally worked, I was just relieved to move on and did not take a moment and think about future readers of this code fragment. An expensive mistake on my end. 36 37## What should I comment? 38 39![why.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1650709483844/R_v9Rlyn3.png) 40Okay, so commenting can be important. But then what should I comment? If you remember one thing from this article let it be to **comment *why *rather than *what***. It\u0026#39;s the biggest timesaver you can give to the future reader of a code fragment. 41The reasoning behind a code fragment is the key to understanding it. 42 43## \u0026#34;My code is self-explanatory\u0026#34; 44When you write code, you know why you write it. I call this the *illusion of self-explanation*. When you are writing code its meaning is indeed obvious to you because you have a whole context loaded in your head for this piece of code. Future readers often will not have this and need some help. 45 46It is also the most heard argument against writing comments: the preference for writing self-explanatory code over code with comments. I believe they are separate things. Applying proper naming and code structuring is also required to keep code readable, but a lot of *why* (explanation) just does not fit in *what* (code). 47 48## Contagious Code and its Vaccine 49Good programmers never reinvent the wheel. When programmers need a solution or implementation, they search Stackoverflow or more specifically: look in their own codebase if they solved the problem before already. If they did, they are happy to copy this proven solution instead of figuring out their own, and rightfully so. This is how certain code can \u0026#39;reproduce\u0026#39; to new applications. I call this **contagious code**. 50 51Contagious code is not a bad thing. I would argue that (if it can\u0026#39;t be extracted) contagious code is a *good* thing as it provides consistency to the reader. However, there is a catch. If there is some dead code or technical debt hidden in that copied code, it is duplicated along. You want the same behavior, so you copy it. Now, of course, the copier could start pruning the copied code to find out if there are parts they do not need, but again this takes time. Time that can be reduced by explaining your code. **Comments can avoid useless or even harmful code to be copied, i.e. to reproduce.** 52 53Let me illustrate this with another example, for those who are interested. This time on Kafka configuration: 54 55```yaml 56kafka: 57 consumer: 58 max-attempts: 3 59 back-off-initial-interval: 70000 60 back-off-multiplier: 2 61 auto-offset-reset: latest *One day I stumbled onto this fragment in a recently created new microservice. For now, you don't need to understand the code's meaning, but in short: it configures a Kafka message consumer in a microservice. The last line, however, was clearly copied. It states that the first time the consumer starts, it should start at the last message, instead of the first. This line was purely here because one specific other microservice uses this. Several other microservices copied the full Kafka configuration from that one service, assuming it was what they needed since they wanted to use Kafka in the same way. * Of course, this would not have happened if the creator of the new microservice had read every line they copied, critically. But this fragment is typically part of a 100+ config file that is copied as a sort of template. So what would be an easier way of avoiding malicious contagious code?\nYou probably guessed it. Add a comment to non-standard configuration like this. This will trigger the future copier to double-check if they need that line:\n1kafka: 2 consumer: 3 max-attempts: 3 4 back-off-initial-interval: 70000 5 back-off-multiplier: 2 6 auto-offset-reset: latest # Only required here because we want to skip old messages Reveal Hidden Dependencies One of the great features provided by decent IDEs is reference checking. Many times per day I want to know where a method is used and I can find out easily. But what if I want to know why certain application-level configuration was added? What code does it affect? Or why is a certain library included in this application? These implicit dependencies are often hard to track. Unless the writer makes them explicit by adding comments.\nTime for another story, related to the same configuration code fragment:\n1kafka: 2 consumer: 3 max-attempts: 3 4 back-off-initial-interval: 70000 5 back-off-multiplier: 2 6 auto-offset-reset: latest Simply put, this says: A Kafka consumer gets three attempts at processing a message. If the first attempt fails, try it again in 70 seconds. If that fails, try it one more time after another 140 seconds. Then give up and discard the message.\n*How was the value of 70 seconds chosen? It seems such an odd amount. It's not an even minute, nor a power of two. *\nWell, the inside knowledge you need to answer this question is that an external package configures the time a consumer gets for its three attempts combined: 200 seconds. What happens if I change the 70 to 60 seconds? The three attempts will be executed in roughly 180 seconds: before that timeout of 200 seconds. The message will be discarded by the consumer.\nWhat happens then if the value remains 70 seconds? The 200 seconds consumer timeout ends before the third attempt is started (after 210 seconds). Kafka believes the consumer to be nonresponsive and the message is given to a different consumer before the message is discarded. The other consumer is allowed to start a new cycle of 3 attempts, and so on. This implies that the message will never be discarded. The application thus functions fundamentally different when changing the back-off-initial-interval value, but this is not self-explanatory! It does so in relation to the consumer timeout. Problems can be avoided by making these hidden connections between code visible using comments.\nBeware of Comment-Code Duplications Technical debt is always right around the corner, even when writing comments. Take a look at this made-up pseudocode fragment of a simple webshop:\n1function determineOrderOfItem(item) { 2 if (item.category === \u0026#34;General\u0026#34;) { 3 item.order = 0; 4 } 5 ... 6} If I read this code for the first time I ask myself: why is this logic necessary? Well, let's assume the writer of this code considered the possible confusion of future readers and added a comment to clarify this:\n1function determineOrderOfItem(item) { 2 // Our client wants items of the general category to be rendered first as they sell better. 3 if (item.category === \u0026#34;General\u0026#34;) { 4 item.order = 0; 5 } 6 ... 7} There. Now when a new developer comes along this code they understand the intent of the code. However, as time goes by, a second client comes along. This new client is a pet store and wants all items related to cats to be rendered first. The original writer knows what to do, and changes the code to accommodate this in a future-proof manner:\n1function determineOrderOfItem(item, priorityCategory) { 2 // Our client wants items of the general category to be rendered first as they sell better. 3 if (item.category === priorityCategory) { 4 item.order = 0; 5 } 6 ... 7} That was not so hard either, but as you probably noticed they did not change the comment.\nAgain, a new developer comes by this code. They read the comment to understand it and run the code for the pet store. They notice that priorityCategory is \u0026quot;cat\u0026quot;. Now the developer is asking themselves: Is this a bug? Should \u0026quot;general\u0026quot; be passed here, or is the commenting wrong? To find this out they will start analyzing the code history and unit tests and ask the business or the client to find out if the code is correct or not.\nNow there are several ways this confusion could have been avoided, but I believe the root cause is the duplication of the magic string \u0026quot;general\u0026quot; in the comments. Even if developers remember to change the comments along with the code, the problem is they have to do two modifications: one in the code and one in the comments. Avoid time-consuming confusion and technical debt by not duplicating magic values into your comments.\nConclusion Good programmers write good comments as well. Poorly commented code behaves as technical debt. Interest on it is paid every time a reader is confused about its meaning and has to spend more time on understanding it.\nAs programming consists primarily of reading, hours of time can be saved in the future by properly commenting your code in the present. Use these guidelines when thinking of comments to add:\n**Comment why rather than what Add comments even when you think code is self-explanatory Point out non-standard parts in your code, to guide future readers to what is important Do not duplicate logic or magic values into comments These tips are just the tip of the iceberg but I believe they will bring your commenting skills to the next level.\nIf you have more tips yourselves, please leave a comment!\n","link":"https://example.com/posts/the-most-undervalued-skill-of-programmers/","section":"posts","tags":["commenting"],"title":"The Most Undervalued Skill of Programmers"},{"body":"Software developers are expensive. Managers or product owners are always struggling to account for every hour that we as programmers work. Why then would they ever agree to let half of their developers simply watch others? Because in many cases it saves more time than it costs.\nWhat is Pair Programming First of all, there is no one way of pair programming. martinFowler.com gives a nice overview of some common styles. In this article, I will use the following definition for pair programming:\nWorking on a single story with more than one developer\nThe key takeaway of this definition is that you don't have to work on a single machine all the time. Everything from occasional sparring to constantly sharing a keyboard is in some form of pair programming.\nIn the sections below I will discuss some forms of pair programming and their added value.\nThe Kickoff By a kickoff, I mean a gettogether of two or more developers to discuss the technical solution to a story or task in advance. It is one of the simplest forms of pair programming, but it can nonetheless be of great value.\nThe kickoff derives its value from avoiding technical implementations that later require refactoring. In other words: from limiting technical debt. Technical debt (TD), like regular debt, requires resolving (refactoring). Up till then, interest in some form is paid. Without going into much detail on TD know that avoiding it saves a lot of time in the future.\nAvoiding TD in a story often means forgetting as little as possible. Although team members share a good portion of their knowledge, every member has unique insights. Person A might tend to forget scalability, but person B always considers this first. He however tends to have a blind spot for security. Person C might know an existing library, which would immensely reduce implementation time, etcetera. This gives rise to the diagram below:\nInstead of trying to come up with all the forces, problems, and potential solutions for a story yourself, join forces with a colleague. You can discuss things in advance so you don't have to rework things later.\nDeveloping Together Once the story's desired implementation is clear it is time to start coding. This is also the time you can choose to do traditional pair programming. One developer writes (the writer) and the other reads along (the reader). For this style to work it is very important that the reader does not get distracted. This is because the reader is in a special position. The writer has to focus on typing, syntax, and other low-level decision-making where the reader can zoom out. They can look back, look ahead and look around. For the reader it is easier to see possible refactorings, emerging patterns, emerging code duplication, etcetera. All these ideas that the reader might come up with can be implemented during the development instead of being suggested after the story at the code review. At that time, major refactoring might be required which makes it tempting to just \u0026quot;let things be\u0026quot; (enter more technical debt).\nDebugging Together Debugging can be a very time-consuming matter which can be limited by pair programming. Just the practice of rubber duckying can help solve problems. Walking through code with someone that has a fresh perspective often identifies problems much faster, because they have no bias toward your implementation. Finally debugging the same problem in parallel can be fruitful when you are dealing with complex bugs.\nComplex bugs are like escape rooms. To solve an escape room, a series of insights is required. Person A might find the first puzzle solution very quickly but blank on the second puzzle. This is where person B comes in with a different perspective, solving the second puzzle. Then person A immediately sees what needs to be done for puzzle three, etcetera. This shows that working together can immensely speed up the process of solving complex problems.\nCode Ownership and Mentoring All forms of pair programming have the additional benefit of distributing knowledge. Pair programming distributes code ownership because more people are familiar with the code that was written. Moreover, team members automatically learn each other's development methods. Maybe you see your colleague use a shortcut or plugin you did not know existed, maybe they work test-first, or you get an insight into how other developers debug certain problems that are way less cumbersome than your own methods. All this increases the long-term productivity of the involved developers.\nWhen not to Pair Program Pair programming is not a silver bullet. There are stories and tasks that are less suited for pair programming. These stories are simple stories that all team members know how to complete and would typically use the same solution to do so. Barely any knowledge transfer would occur during these stories and the reader of the pair would have little to no benefit from his perspective. Some examples of tasks where I would choose not to pair program would be\nChanging a well-known configuration property or text constants Writing unit tests for simple code (with little logic) Implementations that are repetitive from the team's perspective (everyone has done them many times) Conclusion Pair programming is an undervalued practice that can have long-term and short-term benefits for developers and their companies. When next you want to convince your supervisor that pair programming is worth it, remember that pair programming:\nReduces technical debt accumulation, saving time in the future Can drastically reduce debugging effort Lets developers learn from eachother Spreads knowledge across team members Does not mean permanently working on one machine When applied at the right time, pair programming will bring your development team to the next level, so pair up!\n","link":"https://example.com/posts/why-you-should-start-pair-programming-tomorrow/","section":"posts","tags":["pair-programming"],"title":"Why You Should Start Pair Programming Tomorrow"},{"body":"","link":"https://example.com/categories/","section":"categories","tags":null,"title":"Categories"},{"body":"","link":"https://example.com/posts/","section":"","tags":null,"title":"Posts"},{"body":"","link":"https://example.com/search/","section":"","tags":null,"title":"Search"},{"body":"","link":"https://example.com/series/","section":"series","tags":null,"title":"Series"}]